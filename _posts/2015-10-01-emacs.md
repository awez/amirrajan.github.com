---
title: Why Emacs?
category: software-development
layout: post
tags : [code]
---

## tl;dr; ##

Used Visual Studio for many years, used Vim for many years, changed to
Emacs because its Vim bindings were spot on, and the editor provides
discoverability elements that make it easy to extend.

If your editor can do the key points in this blog entry, then there is
no reason to pick up Emacs. If your editor can't do the things in this
list (or it's very very hard and not fun to do), then you are not
using an IDE, you're using a ball and chain clasped firmly around your
neck. You're going to spend probably _two decades_ coding, why
be hindered by your IDE throughout your journey?

# History: Moving Away From Visual Studio and Vim #

I moved away from Visual Studio back in 2010. I started doing building
automation using rake. And Visual Studio's Ruby support was non
existant. That and I was doing more JavaScript, SCSS, and LESS. All of
which had subpar (nonexistant) support. I did all my C# development in
Visual Studio, but any other text editing that needed to be done, was
in Vim.

I got really good and using Vim bindings and felt utterly broken in
Visual Studio. Moving around using the mouse and arrow keys added so
much cognative overhead when all I wanted to do was get what I had in
my head, through the keyboard, and on the screen as fast as
possible. The best way to explain Vim bindings is this:

>Imagine you're a samurai with a razor sharp sword, contemplating how
>to take down your opponent. You think, the entire sequence is in your
>mind of how you'll cut down your foe. Your blade remains sheathed,
>because you aren't ready to strike just yet.
>
>Clarity comes, and the path to victory can be seen in your mind's
>eye. You unsheath your katana to attack. Within an instant, each
>intricate slash is executed, and your blade is placed back at your
>side. Your foe falls, a buttefly fluttering through the air splits in half mid
>flight, only after realizing it's been cut.

The unsheathing of the blade is synonymous to going into Vim's insert
mode. Using the mouse and arrow keys, is synonymous to a combination
padlock latched on to your sheath (which has to be unlocked every time
you want to use it).

With Vim bindings, the cognative overhead _between_ "thinking time"
and "writing time" _disappeared_.

What I also found was that my ability to edit code in _all_ languages
increased (albiet with a small productivity loss in editing C#). The
same key bindings and motions could be applied to refactor code, no
matter the language. I want to reiterate this, *Vim bindings makes you
efficient in editing and refactoring code in _all_ languages, at the
cost of extreme efficiency in one.*

That's what happened to me. *It became more important for me to be
proficient in editing the sum of JavaScript, Rake, CSS, SCSS, Html5,
Jade, and Markdown, over just being efficient in editing C#.*

I went so far as [creating a set of instructions for coding C# in Vim
on Windows back in 2012](https://github.com/amirrajan/katanspec/) when
it wasn't cool to use an editor other than Visual Studio to code C#.

# History: Moving Away From Vim #

My main motivation for moving away from Vim was VimScript and the ["Tim
Pope Bus"](http://www.vim.org/account/profile.php?user_id=9012). I
just didn't want to invest in learning VimScript, but felt that my
lack of scripting knowledge was limiting my ability to extend Vim even
further than my plugin suite. Yes, I'm aware of NeoVim, and if you can
do "the list of things you should know how to do with your editor", in
NeoVim, then you're gold.

Aside: Emac's Vim bindings are incredible. As stated earlier, I can't
imagine editing code without them. **It's the main reason why I
couldn't make the switch to editors such as Sublime, Atom, Eclipse, or
Xamarin Studio, XCode, AppCode, et al. These other editors have
cursory Vim support, but nuanced commands just aren't there (such as
`[ESC]V5jA;[ESC]`).**

TODO:

- Find out what function is being executed by a key stroke.
- Find out what key stroke a function is bound to.
- Search for related functions.
- Execute editor functions by typing them in.
- Eval editor functions at a whim.
- Create small functions myself that use other functions.
- It has an easy way for me to bind a function to a leader key combonation (evil-leader).
- Easy to view source for a function I'm using.
- It isn't vim script, I'm off the Tim Pope bus, Mads Kritchesten bus.
