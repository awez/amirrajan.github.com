

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" >
<head><title>
	
    
    Code Blog Foo: introduction-to-behavior-driven-development-and-mocking

</title><link href="../Content/base.css" rel="stylesheet" type="text/css" />
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    
    <script src="../../Scripts/shAll.js" type="text/javascript"></script>
    <link href="../../Content/SyntaxHighlighter.css" rel="stylesheet" type="text/css" />
</head>
<body>
<strong>This is an archive of blog posts from a "long time ago".  If you find this useful, let me know and I'll revive it.</strong>
    <div class="wrap">
        
        <div id="top group">
            <header>
                <h1>code blog foo - tag line bar</h1>
            </header>
            <div style="padding: 5px; border-bottom: 1px solid silver; border-top: 1px solid silver;">
                <nav>
                    <a href="/" style="margin-left: 15px; border-style: solid; border-width: 1px;">home</a>
                    <span class="sep"></span>
                    <a href="/Blog/Posts" style="margin-left: 15px; border-style: solid; border-width: 1px;">blog</a>
                    <a href="/Home/About" style="margin-left: 15px; border-style: solid; border-width: 1px;">about</a>
                    <a href="/Home/Portfolio" style="margin-left: 15px; border-style: solid; border-width: 1px;">projects/open source</a>
                </nav>
            </div>
        </div>
        
        <div class="content">
            
    
    
    <script type="text/javascript">
        window.onload = function () {
            SyntaxHighlighter.config.clipboardSwf = '/Scripts/clipboard.swf';
            SyntaxHighlighter.all();
            dp.SyntaxHighlighter.HighlightAll('code');
        };

     </script>
    <h2>Introduction to Behavior Driven Development and Mocking in .Net</h2>

<h3>Warning</h3>
<p>
This is a <strong>long and dense</strong> post that will take a lot of concentration to get through.  Also, this is entirely my opinion on what I consider to be "effective" unit testing, so take the time to digest what is written and make your own evaluations (think critically).
</p>

<h3>Setting the Stage</h3>
<p>
I don't want to waste your time, because I know it's valuable.  Also, if you have any questions or need any clarifications, please don't hesitate to email me (ar@amirrajan.net).  So before you start reading, make sure:
</p>
<ul>
    <li>You really want to learn how to effectively unit test.</li>
    <li>You understand dependency injection.</li>
    <li>You know how to get around with MSTest or NUnit.</li>
</ul>

<p>
    I really don't like trivial examples.  So again, this is pretty dense code that is actually being used in one of my web sites (borrowedgames.com).  So take the time to really take it in. Let's start drinking from the fire hose shall we?
</p>

<h4>IMessageManager</h4>

<p>
In my web site, I have added messaging capabilities (you can send and receive internal messages from a user...very similar to what you would see in Facebook or LinkedIn).  Here is the interface specification for my "MessageManager".
</p>

<pre name="code" class="c#">
public interface IMessageManager
{
    void SendMessage(Guid senderUserId, 
        Guid recipientUserId, 
        string subject, 
        string body, 
        DateTime sendDate);
    void MarkMessageAsRead(Guid ownerUserId, Guid messageId);
    void DeleteInboxMessage(Guid ownerUserId, Guid messageId);
    void DeleteOutboxMessage(Guid ownerUserId, Guid messageId);
}
</pre>

<h4>MessageManager : IMessageManager</h4>

<p>
And this is the concrete implementation of the IMessageManager.  We'll go through this code line by line so we understand what we will be testing.
</p>

<pre name="code" class="c#">
public class MessageManager : IMessageManager
{
    private IUserInboxSaver _userInboxSaver;
    private IUserOutboxSaver _userOutboxSaver;
    private IUserInboxRetriever _userInboxRetriever;
    private IUserOutboxRetriever _userOutboxRetriever;

    public MessageManager(IUserInboxSaver userInboxSaver, 
        IUserOutboxSaver userOutboxSaver, 
        IUserInboxRetriever userInboxRetriever, 
        IUserOutboxRetriever userOutboxRetriever)
    {
        _userInboxSaver = userInboxSaver;
        _userOutboxSaver = userOutboxSaver;
        _userInboxRetriever = userInboxRetriever;
        _userOutboxRetriever = userOutboxRetriever;
    }

    void IMessageManager.SendMessage(Guid senderUserId, 
        Guid recipientUserId, 
        string subject, 
        string body, 
        DateTime sendDate)
    {
        _userInboxSaver.SaveInboxMessage(Guid.NewGuid(), 
            senderUserId, 
            recipientUserId, 
            subject, 
            body, 
            true, 
            sendDate);

        _userOutboxSaver.SaveOutboxMessage(Guid.NewGuid(), 
            senderUserId, 
            recipientUserId, 
            subject, 
            body, 
            sendDate);
    }

    void IMessageManager.MarkMessageAsRead(Guid ownerUserId, Guid messageId)
    {
        if(_userInboxRetriever.InboxMessageExists(ownerUserId, messageId))
        {
            _userInboxSaver.SetIsNew(messageId, false);
        }
    }

    void IMessageManager.DeleteInboxMessage(Guid ownerUserId, Guid messageId)
    {
        if(_userInboxRetriever.InboxMessageExists(ownerUserId, messageId))
        {
            _userInboxSaver.DeleteInboxMessage(messageId);
        }
    }

    void IMessageManager.DeleteOutboxMessage(Guid ownerUserId, Guid messageId)
    {
        if (_userOutboxRetriever.OutboxMessageExists(ownerUserId, messageId))
        {
            _userOutboxSaver.DeleteOutboxMessage(messageId);
        }
    }
}
</pre>

<h4>MessageManager Dependencies</h4>

<p>
    Notice that the concrete implementation of MessageManager depends on the following repository/database interfaces: IUserInboxSaver, IUserOutboxSaver, IUserInboxRetriever, IUserOutboxRetriever.  Here are the interface definitions.
</p>

<pre name="code" class="c#">
public interface IUserInboxSaver
{
    void SaveInboxMessage(Guid messageId, 
        Guid senderUserId, 
        Guid recipientUserId, 
        string subject, 
        string body, 
        bool isNew, 
        DateTime sendDate);
    void SetIsNew(Guid messageId, bool isNew);
    void DeleteInboxMessage(Guid messageId);
}

public interface IUserOutboxSaver
{
    void SaveOutboxMessage(Guid messageId, 
        Guid senderUserId, 
        Guid recipientUserId, 
        string subject, 
        string body, 
        DateTime sendDate);
    void DeleteOutboxMessage(Guid messageId);
}

public interface IUserInboxRetriever
{
    bool InboxMessageExists(Guid ownerUserId, Guid messageId);
    List&lt;IMessage&gt; GetNewInboxMessages(Guid ownerUserId);
    List&lt;IMessage&gt; GetReadInboxMessages(Guid ownerUserId);
    IMessageWithBody GetInboxMessage(Guid ownerUserId, Guid messageId);
}

public interface IUserOutboxRetriever
{
    bool OutboxMessageExists(Guid ownerUserId, Guid messageId);
    List&lt;IMessage&gt; GetOutboxMessages(Guid ownerUserId);
    IMessageWithBody GetOutboxMessage(Guid ownerUserId, Guid messageId);
}
</pre>

<h4>Line by Line</h4>

<p>
    So far so good?  Alright, time for the line by line.  Let's start with the constructor.
</p>

<pre name="code" class="c#">
    private IUserInboxSaver _userInboxSaver;
    private IUserOutboxSaver _userOutboxSaver;
    private IUserInboxRetriever _userInboxRetriever;
    private IUserOutboxRetriever _userOutboxRetriever;

    public MessageManager(IUserInboxSaver userInboxSaver, 
        IUserOutboxSaver userOutboxSaver, 
        IUserInboxRetriever userInboxRetriever, 
        IUserOutboxRetriever userOutboxRetriever)
    {
        _userInboxSaver = userInboxSaver;
        _userOutboxSaver = userOutboxSaver;
        _userInboxRetriever = userInboxRetriever;
        _userOutboxRetriever = userOutboxRetriever;
    }
</pre>

<p>
    Pretty straight forward constructor.  MessageManager depends on a few repository interfaces to store messages in the database.  Each user has an Inbox and an Outbox....and the retrievers and savers facilitate the persistence and retrieval of the messages.  Now for the SendMessage() method.
</p>

<pre name="code" class="c#">
    void IMessageManager.SendMessage(Guid senderUserId, 
        Guid recipientUserId, 
        string subject, 
        string body, 
        DateTime sendDate)
    {
        _userInboxSaver.SaveInboxMessage(Guid.NewGuid(),     //messageId
            senderUserId,                                    //senderId
            recipientUserId,                                 //recipientId
            subject,                                         //subject
            body,                                            //body
            true,                                            //isNew
            sendDate);                                       //datesent

        _userOutboxSaver.SaveOutboxMessage(Guid.NewGuid(),   //messageId
            senderUserId,                                    //senderId
            recipientUserId,                                 //recipientId
            subject,                                         //subject
            body,                                            //body
            sendDate);                                       //sendDate
    }
</pre>

<p>
    The SendMessage() method, adds the message entry in the sender's outbox and inserts the same message in the recipients inbox.  Also, the inbox message is marked as a new message.  Since Guid.NewGuid() is passed in for the messageId, a message would get inserted in both the sender's outbox and the recipient's inbox (the messageId is a primary key in the database).  Now for the MarkMessageAsRead() method.
</p>

<pre name="code" class="c#">
void IMessageManager.MarkMessageAsRead(Guid ownerUserId, Guid messageId)
{
    if(_userInboxRetriever.InboxMessageExists(ownerUserId, messageId))
    {
        _userInboxSaver.SetIsNew(messageId, false);
    }
}
</pre>

<p>
Given the owner and the message id, the repository is queried to see if the message exists.  If it does then the message's IsNew property is set to false using _userInboxSaver.SetIsNew().  The method would go to the database, find the message and set the IsNew column to 0 for that particular message.  Now for DeleteInboxMessage() and DeleteOutboxMessage().
</p>

<pre name="code" class="c#">
void IMessageManager.DeleteInboxMessage(Guid ownerUserId, Guid messageId)
{
    if(_userInboxRetriever.InboxMessageExists(ownerUserId, messageId))
    {
        _userInboxSaver.DeleteInboxMessage(messageId);
    }
}

void IMessageManager.DeleteOutboxMessage(Guid ownerUserId, Guid messageId)
{
    if (_userOutboxRetriever.OutboxMessageExists(ownerUserId, messageId))
    {
        _userOutboxSaver.DeleteOutboxMessage(messageId);
    }
}
</pre>

<p>
Each method first queries the repository to ensure that the message exists for the owner and the message id.  If the combination exists then the respective delete method is called.  A delete sql statement would get generated and executed inside of the DeleteInboxMessage() and DeleteOutboxMessage() methods.
<p>

<h3>The Unit Tests (BDD Style)</h3>
<p>
Whew...that was a lot of explanation (make sure you understand what MessageManager is doing before reading on)...now that the stage is set, let's look at how to test this class.
</p>

<h4>Naming</h4>
<p>
The key to naming your tests is to make them as human readable as possible.  It is 100% okay to have class names that are really long (and method names that are even longer).  You want these unit tests to document the behavior of the code so that any developer can jump in, look at the unit tests, and have a pretty good understanding of what you are trying to do.
</p>

<h4>The .cs Files and the Methods</h4>
<p>
You'll have many .cs files to fully test one class.  In the case of MessageManager, I had to create four .cs files.  Each .cs file has behavioral style methods....you'll probably have a .cs file for each method in a class (use your best judgement on this...start with one .cs file...the very moment you see your test initialization getting too complicated, start breaking it up).   <strong>Here are the names of the .cs files and the method names</strong>:
</p>
<ul style="line-height: 200%">
    <li>
        when_sending_message.cs
        <ul>
            <li>should_insert_message_into_senders_outbox()</li>
            <li>should_insert_message_into_recipients_inbox()</li>
        </ul>
    </li>
    <li>
        when_marking_inbox_message_as_read.cs
        <ul>
            <li>
                should_set_IsNew_to_false_if_message_exists_<br/>
                for_ownerid_and_messageid_combination()
            </li>
            <li>
                should_disregard_updating_the_message_if_message_<br/>
                does_not_exist_for_ownerid_and_messageid_combination()
            </li>
        </ul>
    </li>
    <li>
        when_deleting_inbox_message.cs
        <ul>
            <li>
                should_delete_message_if_message_exists_<br/>
                for_ownerid_and_messageid_combination()
            </li>
            <li>
                should_disregard_deletion_of_message_if_message_<br/>
                does_not_exist_for_ownerid_and_messageid_combination()
            </li>
        </ul>
    </li>
    <li>
        when_deleting_outbox_message.cs
        <ul>
            <li>
                should_delete_message_if_message_exists_<br/>
                for_ownerid_and_messageid_combination()
            </li>
            <li>
                should_disregard_deletion_of_message_if_message_<br/>
                does_not_exist_for_ownerid_and_messageid_combination()
            </li>
        </ul>
    </li>
</ul>

<h3>Time to Test...and Mock</h3>
<p>
Let's look at the scaffolding for when_sending_message.cs.
</p>

<pre name="code" class="c#">
[TestClass]
public when_sending_message
{
    private IMessageManager _messageManager; //this is the class we will test
    public when_sending_message()
    {
        //_messageManager initialization will go here
    }

    [TestMethod]
    public void should_insert_message_into_senders_outbox()
    {

    }

    [TestMethod]
    public void should_insert_message_into_recipients_inbox()
    {

    }
}
</pre>

<p>
    After creating the scaffold, we need to initialize _messageManager in the constructor so we can test it.  If you recall, the concrete implementation of MessageManager has a few dependencies: IUserInboxSaver, IUserOutboxSaver, IUserInboxRetriever, IUserOutboxRetriever.  <strong>We do not want to test MessageManager's dependencies.  So that means we cannot (and should not) use the concrete implementations of these interfaces.  We have to use mocks to orchestrate what the concrete implementation of these repository classes would have done.</strong>
</p>

<h3>Manually Making Your Mocks</h3>
<p>
    I used to manually create my mocks.  It was fairly easy and didn't require me to spend time on learning a mocking framework...I don't any more, but I'll let you make that decision for yourself.  I'll show how to both manually mock your dependencies and how to mock using a mocking framework (I use Moq....it's awesome).
</p>

<p>
   So the problem....I need to new up a MessageManager, and provide mocks for all the interfaces that this class needs.  <strong>You can accomplish this by having your unit test class implement each interface MessageManager needs</strong>.  Take a look.
</p>

<pre name="code" class="c#">
[TestClass]
public when_sending_message :
       IUserInboxSaver, 
       IUserOutboxSaver, 
       IUserInboxRetriever, 
       IUserOutboxRetriever
{
    private IMessageManager _messageManager; //this is the class we will test
    public when_sending_message()
    {
        //all the interfaces have been implemented 
        //and either do nothing or return a default value.
        //now that when_sending_message implements 
        //all the interfaces needed by MessageManager,
        //I can now new it up.

        //"this" (being the unit test class) is passed in 
        //for each parameter of messagemanager
        _messageManager = new MessageManager(this, this, this, this);  
     }

    [TestMethod]
    public void should_insert_message_into_recipients_inbox()
    {

    }

    [TestMethod]
    public void should_insert_message_into_senders_outbox()
    {

    }

    #region IUserInboxSaver Members

    void IUserInboxSaver.SaveInboxMessage(Guid messageId, Guid senderUserId, Guid recipientUserId, string subject, string body, bool isNew, DateTime sendDate)
    {

    }

    void IUserInboxSaver.SetIsNew(Guid messageId, bool isNew)
    {

    }

    void IUserInboxSaver.DeleteInboxMessage(Guid messageId)
    {

    }

    #endregion

    #region IUserOutboxSaver Members

    void IUserOutboxSaver.SaveOutboxMessage(Guid messageId, Guid senderUserId, Guid recipientUserId, string subject, string body, DateTime sendDate)
    {
 
    }

    void IUserOutboxSaver.DeleteOutboxMessage(Guid messageId)
    {

    }

    #endregion

    #region IUserInboxRetriever Members

    bool IUserInboxRetriever.InboxMessageExists(Guid ownerUserId, Guid messageId)
    {
        return false;
    }

    List&lt;IMessage&gt; IUserInboxRetriever.GetNewInboxMessages(Guid ownerUserId)
    {
        return null;
    }

    List&lt;IMessage&gt; IUserInboxRetriever.GetReadInboxMessages(Guid ownerUserId)
    {
        return null;
    }

    IMessageWithBody IUserInboxRetriever.GetInboxMessage(Guid ownerUserId, Guid messageId)
    {
        return null;
    }

    #endregion

    #region IUserOutboxRetriever Members

    bool IUserOutboxRetriever.OutboxMessageExists(Guid ownerUserId, Guid messageId)
    {
        return false;        
    }

    List&lt;IMessage&gt; IUserOutboxRetriever.GetOutboxMessages(Guid ownerUserId)
    {
        return null;
    }

    IMessageWithBody IUserOutboxRetriever.GetOutboxMessage(Guid ownerUserId, Guid messageId)
    {
        return null;        
    }

    #endregion
}
</pre>

<p>
   Alright.  We've newed up MessageManager...now let's flush out the should_insert_message_<br/>
   into_recipients_inbox() method.
</p>

<pre name="code" class="c#">
[TestMethod]
public void should_insert_message_into_recipients_inbox()
{
    Guid senderId = Guid.NewGuid();
    Guid recipient = Guid.NewGuid();

    _messageManager.SendMessage(senderId, recipientId, "subject", "body", DateTime.Today);

    //make sure a new guid was generated for the message id
    Assert.AreNotEqual(Guid.Empty, _lastInboxMessageId);

    //make sure that rest of the parameters match up as expected
    Assert.AreEqual(senderId, _lastInboxSenderUserId);
    Assert.AreEqual(recipientUserId, _lastInboxRecipientUserId);
    Assert.AreEqual("subject", _lastInboxSubject);
    Assert.AreEqual("body", _lastInboxBody);
    Assert.AreEqual(DateTime.Today, _lastInboxSendDate);

    //ensure that the inbox message is marked as new
    Assert.AreEqual(true, _lastInboxIsNew);
}

[...]

private _lastInboxMessageId;
private _lastInboxSenderUserId;
private _lastInboxRecipientUserId;
private _lastInboxSubject;
private _lastInboxBody;
private _lastInboxIsNew;
private _lastInboxSendDate;

void IUserInboxSaver.SaveInboxMessage(Guid messageId, Guid senderUserId, Guid recipientUserId, string subject, string body, bool isNew, DateTime sendDate)
{
   //since we injected this unit test class
   //as the IUserInboxSaver, this method will
   //be called any time MessageManager calls SaveInboxMessage.
   //we need to record what was given as the parameters so we
   //can do our assertions.  This method essentially
   //orchestrates the insertion of the message into the database.

   _lastInboxMessageId = messageId;
   _lastInboxSenderUserId = senderUserId;
   _lastInboxRecipientUserId = recipientUserId;
   _lastInboxSubject = subject;
   _lastInboxBody = body;
   _lastInboxIsNew = isNew;
   _lastInboxSendDate = sendDate;
}
</pre>

<p>
    The should_insert_message_into_senders_outbox() method would be tested in the same fashion.  The mocked method would record the parameters that it was given and the unit test would perform assertions on those parameters.
</p>

<p>
    If you are thinking this is a lot of work to effectively unit test...well then you're right.  It just comes down to how much you value stable code (and how much it will cost if you introduce a bug into a production environment).  Unit tests are necessary.  Period.  They are an essential part of software engineering (and we all see software as a science/craft).  Thankfully, mocking frameworks (like Moq) will make your life a lot easier.
</p>

<h3>Making Your Mocks With Moq</h3>
<p>
    Here is how you would new up the MessageManager class using <a href="http://code.google.com/p/moq/">[Moq]</a>.
</p>

<pre name="code" class="c#">
using Moq;

[TestClass]
public class when_sending_message
{
    private IMessageManager _messageManager;
    private Mock&lt;IUserInboxSaver&gt; _userInboxSaver;
    private Mock&lt;IUserOutboxSaver&gt; _userOutboxSaver;
    private Mock&lt;IUserInboxRetriever&gt; _userInboxRetriever;
    private Mock&lt;IUserOutboxRetriever&gt; _userOutboxRetriever;

    public when_sending_message()
    {
        _userInboxSaver = new Mock&lt;IUserInboxSaver&gt;();
        _userOutboxSaver = new Mock&lt;IUserOutboxSaver&gt;();
        _userInboxRetriever = new Mock&lt;IUserInboxRetriever&gt;();
        _userOutboxRetriever = new Mock&lt;IUserOutboxRetriever&gt;();

        _messageManager = 
            new MessageManager(_userInboxSaver.Object,
                               _userOutboxSaver.Object,
                               _userInboxRetriever.Object,
                               _userOutboxRetriever.Object);
    }

    [TestMethod]
    public void should_insert_message_into_recipients_inbox()
    {

    }

    [TestMethod]
    public void should_insert_message_into_senders_outbox()
    {

    }
}
</pre>

<p>
   Notice something?  The unit test doesn't need to implement every interface.  All you have to do is declare a Mock of each interface and inject the mock into the MessageManager class.  Now for the real magic.  Lets see what the unit test looks like for should_insert_message_into_<br/>
recipients_inbox().
</p>

<pre name="code" class="c#">
[TestMethod]
public void should_insert_message_into_recipients_inbox()
{
    Guid senderId = Guid.NewGuid();
    Guid recipientId = Guid.NewGuid();

    _messageManager.SendMessage(senderId, recipientId, "subject", "body", DateTime.Today);

    //verify that the _userInboxSaver.SaveInboxMessage()
    //method was called 
    _userInboxSaver.Verify(
        s => s.SaveInboxMessage(It.IsAny&lt;Guid&gt;(), //message id can be any guid
                 senderId, //sender id
                 recipientId, //recipient id
                 "subject", //subject line
                 "body", //body of message
                 true, //should be flagged as a new message
                 DateTime.Today)); //send date should be today
}
</pre>

<p>
    That's it...by calling the Verify method, we can ensure that the parameters passed into SaveInboxMessage were conveyed correctly.  We didn't have to manually store the values, or do any number of assertions.  Moq does all of that for you.  Crazy huh?
</p>

<h3>Tips</h3>
<p>
   That's pretty much all I can give you to get started with creating effective unit tests.  The rest comes down to practice...lots and lots of practice.  Here are a few tips to help you along.
</p>
<ul style="line-height: 150%">
    <li>When testing your repository methods, you'll will have to interact with a database.  Set up your data in a TestInitialize method and use TestCleanup to remove the rows you inserted.  <strong>Do not assume that data will exist in your database (always setup and tear down).  If you can't execute the test on an empty database, you are asking for your suite to fail.</strong>
    </li>
    <li>Your class names for the unit tests should start with the word "when".  For example: when_retrieving_a_customer.cs</li>
    <li>
        If you have really complicated scenarios, use can also use the word "and" in your unit
        test file name.  For example: when_retrieving_a_customer_and_the_customer_is_<br/>
        currently_in_default.cs
    </li>
    <li>
        Use a mocking framework.  It will save you a lot of time and will help you test code that isn't entirely decoupled.
    </li>
    <li>
        Shoot for 100% code coverage on your data access layer and domain model.  Then as time allows, start testing your controllers/presenters (they are more volatile, and hopefully fairly thin given a robust domain model).
    </li>
    <li>
        Test driven development is very difficult and requires discipline.  Start with just making sure that new code is tested (even if you end up writing the unit tests after the feature has been developed).  Eventually, you'll find that you can leverage your unit tests to actually develop new functionality.
    </li>
    <li>
        Unit testing your repository is a real pain to setup and tear down (especially if your development shop has all of its business logic in stored procs).  Start transitioning your data access layer to just being a very lean persistence mechanism and start moving your business logic to your domain model.
    </li>
    <li>
        Speed is important, you want to be able to run all of your unit tests very quickly (this is another reason why you should get as much as you possibly can out of the data access layer....your repository classes should just blindly retrieve, insert, update, and delete).
    </li>
    <li>
        Start abstracting away concrete implementations behind interfaces.  Interfaces are very powerful and will help the maintainability of your code.
    </li>
    <li>
        Try not to use static methods.  They are harder to test.  Using IOC containers (like Unity), for controlling class instantiation.
    </li>
    <li>
        Practice.  Feel free to email me if you have any questions (ar@amirrajan.net).
    </li>
</ul>
    <hr />
    <span style="color: Silver; font-size: small;">Written: 4/13/2010</span>
    
    <script>
        var idcomments_acct = '6ed8d3f7f3b269a55fc308e535627d11';
        var idcomments_post_url;

        var  idcomments_post_id;// = 'http%3A%2F%2Famirrajan.net%2FBlogs%2F' + 'introduction-to-behavior-driven-development-and-mocking';

    </script>
    <span id="IDCommentsPostTitle" style="display:none">Comments</span>
    <script type='text/javascript' src='http://www.intensedebate.com/js/genericCommentWrapperV2.js'></script>
    <script>$("#body").append('<div></div>').html(idcomments_post_id);</script>

        </div>
    </div>
</body>
</html>
